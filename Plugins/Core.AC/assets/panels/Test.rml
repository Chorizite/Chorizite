<rml>
	<head>
    <title>Tooltip</title>
	<style>
      body {
        font-size: 14px;
        font-family: Tahoma;
        padding: 4px;
        background-color: #000000dd;
        border: 1px white;
      }
    </style>
    <script type="">
-- IMMUTABLE makes any Lua table runtime immutable (read-only) where one:
-- - can get defined entries (unsupported key raises error)
-- - cannot add, remove nor change entries
-- - cannot access values at undefined keys nor out of bounds elements
--
-- Usage:
--
-- local IMMUTABLE = require "immutable"
-- local data_table = { 1, 2, 3 } -- regular table
--
-- [1] convert any table to an immutable table:
-- local my_immutable_table = IMMUTABLE.make( data_table )
--
-- [2] or simply using convenience call:
-- local my_immutable_table = IMMUTABLE( data_table )
--
-- [3] or create it on the go (syntax sugar for call with table parameter):
-- local my_immutable_table = IMMUTABLE { 1, 2, 3 }
--
-- API:
--
-- [ IMMUTABLE.make(original_table) ]
-- Function to make a table immutable, including nested tables
-- @param original_table [table] - table to convert to immutable table
-- @return [table] - original table converted to immutable table
--
-- [ IMMUTABLE.is_immutable(table_to_check) ]
-- Function to check if a given table `t` is immutable
-- @param table_to_check [table] - table to check
-- @return [bool] - true if table t is immutable, false otherwise
--
-- Known issues:
--
-- Keys referencing `nil` in the original table will be inaccesible in the immutable table.
-- To prevent unidentified key access, initialize the fields with any other value.
-- 
-- Lua `table` API is not secured against mutability.
-- To prevent it, you can either avoid using table API or override them.
-- Example on how to override table is given in README.
--
-- Author: Pawel Jarosz
-- License: MIT
-- 2024

local WATCHABLE = {}

local immutable_marker = "immutable"
local nil_placeholder = "nil_placeholder"  -- Unique placeholder for nil values

-- Function to check if a given table `t` is immutable
function WATCHABLE.is_immutable(table_to_check)
	return type(table_to_check) == "table" and getmetatable(table_to_check) == immutable_marker
end



local getPath = function(t, k)
  local path = k
  local parent = t.__parent
  local name = t.__name
  while name ~= nil do
    path = name .. "." .. path
    if parent == nil then
      name = nil
    else
      t = parent
      name = t.__parentname
      parent = t.__parent
    end
  end
  return path
end

local recurseHandlers = function(t, key, value)
  local path = getPath(t, key)
  for i,handler in ipairs(t.__handlers) do
    handler(t, key, value, path)
  end
  local parent = t.__parent
  while parent ~= nil do
    for i,handler in ipairs(parent.__handlers) do
      handler(parent, key, value, path)
    end
    parent = parent.__parent
  end
  return path
end

-- Private function to make a table immutable, including nested tables
local function make_immutable_table(original_table, seen, name, parent_table, parent_name)
	seen = seen or {}

	-- Skip making a table immutable if it already is
	if WATCHABLE.is_immutable(original_table) then
		return original_table
	end

	if seen[original_table] then return seen[original_table] end

	-- Create a data table to hold the original data
	local data_table = {}
	seen[original_table] = data_table  -- Keep track of processed tables
  original_table.__name = name
  original_table.__parent = parent_table
  original_table.__parentname = parent_name or (parent_table and parent_table.__name)
	for k, v in pairs(original_table) do
    if k == "__parent" or k == "__name" or k == "__parentname" then
      
		elseif type(v) == "table" and not WATCHABLE.is_immutable(v) then
			data_table[k] = make_immutable_table(v, seen, k, original_table, name)
      print("add sub table:", k, name, getPath(original_table, k))
      original_table[k] = nil
		else
			data_table[k] = v
      original_table[k] = nil
		end
	end

  local handlers = {}

	-- Set the metatable on the original table to make it immutable
	local mt = {
		-- Redirect reads to the data_table
		__index = function(t, key)
			if data_table[key] ~= nil then
				return data_table[key]
      elseif key == "onchange" then
        return function(t, handler)
          table.insert(handlers, handler)
        end
      elseif key == "__name" then
        return name
      elseif key == "__parent" then
        return parent_table
      elseif key == "__parentname" then
        return parent_name or (parent_table and parent_table.__name)
      elseif key == "__handlers" then
        return handlers
			else
				return nil
			end
		end,
		__newindex = function(t, key, value)
      local old_value = data_table[key]
      if type(value) == "table" and not WATCHABLE.is_immutable(value) then
        data_table[key] = make_immutable_table(value, seen, key, t)
      else
        data_table[key] = value
      end
      recurseHandlers(t, key, data_table[key])
		end,
		-- Lock the metatable
		__metatable = immutable_marker,
		-- Custom ipairs iterator
		__ipairs = function(t)
			local function ipairs_iterator(t, i)
				i = i + 1
				local v = data_table[i]
				if v == nil then
					return nil
				else
					return i, v
				end
			end
			return ipairs_iterator, t, 0
		end,
		__pairs = function(t)
			local function next_wrapper(table, key)
				return next(data_table, key)
			end
			return next_wrapper, t, nil
		end,
		__tostring = function()
			return tostring(data_table)
		end,
		__len = function()
			return #data_table
		end,
	}

	setmetatable(original_table, mt)
	return original_table
end

-- Function to make a table immutable, including nested tables
function WATCHABLE.make(original_table, name)
	if type(original_table) ~= "table" then
		error("Expected a table but got " .. type(original_table))
	end
	return make_immutable_table(original_table, nil, name, nil)
end

-- Metatable for the IMMUTABLE module
local mt = {
	-- Allows calling the module directly to create an immutable table
	__call = function(t, table_arg)
		return WATCHABLE.make(table_arg)
	end
}

setmetatable(WATCHABLE, mt)

local test = WATCHABLE.make({ a = 123, b = { c = 123, d = "test", e = {5,6,7} } })

-- triggers on recursive changes
test:onchange(function(t, key, value, path)
  print(string.format("  Changed test table:  key: %s value: %s path: %s", key, value, path))
end)

print("Setting test.a = 456")
test.a = 456
print("Setting test.b.d = hello")
test.b.d = "hello"
print("Removing test.b.e[1]")
table.remove(test.b.e, 1)
print(string.format("Inserting { x = 1 } into test.b.e[%d]", #test.b.e + 1))
table.insert(test.b.e, { x = 1 })
-- add change handler to specific sub-table we just added
test.b.e[#test.b.e]:onchange(function(t, key, value, path)
  print(string.format("  Changed sub-table key: %s value: %s path: %s", key, value, path))
end)
print(string.format("Setting test.b.e[%d].x to 12345", #test.b.e))
test.b.e[#test.b.e].x = 12345
    </script>
	</head>
	<body data-model="Tooltip">
    Hello
	</body>
</rml>